iOS高级面试题
#weak属性如何自动置为nil的？
&runtime对注册的类，会进⾏布局，会将weak对象放⼊⼀个hash表中。⽤
weak指向的对象内存地址作为key，当此对象的引⽤计数为0时会调⽤对象的dealloc
⽅法，假设weak指向的地址为a，那么就会以a为key在这个weak hash表中搜索，
找到所有以a为key的weak对象，从⽽设置为nil。
#类别category与扩展的区别？
&1、分类是用于给原类添加方法的，Category底层它是一个结构体指针，结构体是没有成员变量的列表，只有方法列表。所以不能声明成员变量。只能通过其它形式添加属性，方法交换。
2、如果分类中有和原类同名的方法，会优先调用分类的方法，就是说会忽略原类的方法。同名方法中优先级是：分类>本类>父类。因此开发中尽量不要覆盖原有类。
3、如果多个分类中都有原类的同名方法，那么调用该方法的时候有编译器决定；编译器会执行最后一个参与编译的分类中的方法。
4、分类可以用@property声明属性，但是无法生成成员变量，也无法生成setter、getter方法。编译能过，会有警告。但是如果调用了成员变量就是报错。OC是动态语言，它是可以通过runtime手动添加setter和getter方法。
类扩展是分类的一个特例，是一个匿名分类。比如说.m文件中使用@interface类名；扩展的作用：为一个类添加额外没有的变量，方法和属性
#runtime中，SEL和IMP的区别？
&每个类对象都有一个方法列表，方法列表存储方法名、方法实现、参数类型；SEL是方法名，IMP指向方法实现的首地址。
#OC中runtime的应用场景？
&1.拦截系统自带的方法调用（Method Swizzling）
2.给分类增加属性（Associated Objects）
3.实现字典模型和自动转换（JSONModel、YYModel）
4.获取类的所有属性、方法名称
5.归档解档
#多线程死锁问题
&（1）互斥条件：一个资源每次只能被一个进程使用。
（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
发生死锁一定满足如上四个条件，满足这四个条件不一定死锁。
解决死锁的方法就是：一步线程执行block。
#DSYM文件作用？
&Xcode编译项目后，我们会看到一个同名的dSYM文件，dsym是保存16进制函数地址映射信息的中转文件。dSYM文件都有对应的UUID，crash文件也有自己的UUID，如果UUID一致，就可以通过出错的函数地址去查询dSYM文件中程序对应的函数名和文
件名。大前提是我们需要有软件版本对应的dSYM文件，这也是为什么我们很有必要保存每个发布版本的Archives文件。
#SDWebImage加载url不变图片更新方法？
&那么如何让SDWebImage支持自动更新实现方法有几种：
1、让服务器更新url，也就是说服务器端如果更新了头像，那么就生成新的url(推荐)
2、让服务器端支持cache-control
3、修改SDWebImage，让它支持http的Last-Modified或者etag（前提是服务器端也要支持）
#同步、异步、并行、串行
&1、同步：顾名思义即为一步一步执行线程内的东西。
2、异步：不阻塞当前线程操作，等同于后台跑数据。
3、串行：一个任务执行完毕后，再执行下一个任务。
4、并行：多个任务同时执行。
#GCD与NSOperation的区别？
&1、GCD的核心是C语言写的系统服务，执行和操作简单高效，NSOperation是对GCD更高层次的抽象，这是它们最本质的区别。如果希望自定义任务，建议用NSOperation。
2、依赖关系，NSOperation可以设置两个NSOperation之间的依赖，第二个任务依赖第一个任务完成执行，GCD无法设置依赖关系，不过可以通过dispatch_barrier_async（栅栏函数）来实现这种效果。
3、KVO（键值对观察），NSOperation很容易判断Operation当前的状态（是否执行，是否取消），对此GCD无法通过KVO进行判断。
4、优先级，NSOperation可以设置自身的优先级，但是优先级高的不一定先执行，GCD只能设置队列的优先级，无法在执行的block设置优先级。
5、继承，NSOperation是一个抽象类，实际开发中常用的是两个子类：NSInvocationOperation和NSBlockOperation，同样我们可以定义NSOperation，GCD执行任务可以自由组装，没有继承那么高的代码复用度。
6、效率，直接使用GCD效率确实会高效，NSOperation会多一点开销，但是通过NSOperation可以获得依赖，优先级，继承，键值对观察这些优势，相对于多的那么一点开销来说很划算。
#Runtime底层实现？调用一个方法，发送一个消息，最终怎么可以调用到方法？
&当你向一个OC对象发送消息时，运行时库会根据对象的isa指针找到这个对象所属的类，这个类会包含一个所有实例方法的列表以及一个指向superClass的指针，以方便可以找到父类的实例方法。运行时库会在类的方法列表以及父类们的方法列表中寻找符合这个selector的方法，找到后即运行这个方法。
#实例方法的调用过程？
&1、在对象所属类的《缓存方法列表》中找要调用的方法，找到直接执行
2、对象所属类的《缓存方法列表》中没有找到，就去《类的方法列表》里找，找到了就执行
3、还没有找到，说明这个类自己没有，就会通过super_class去其父类重复执行1.2
4、如果根类还没有找到，那么就是没有了，会转向一个拦截调用的方法，自己可以在拦截调用方法里面做一些处理。
在一个函数找不到时，runtime提供了三种方式去补救：
    1.调用resolveClassMethod:(SEL)sel给个机会让类添加这个实现这个函数
    2.调用forwardingTargetForSelector:(SEL)aSelector让别的对象去执行这个函数
    3.调用forwardInvocation:(NSInvocation *)anInvocation（函数执行器）灵活的将目标函数以其它形式执行
如果都不中，调用doesNotRecognizeSelector抛出异常
#KVC / KVO
&KVC的底层实现：
当一个对象调用setValue方法时，方法内部首先会检查是否存在对应key的set方法，如果存在，就调用set方法。如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值，如果没有找到带下划线的key，就会查找相同名称的属性key，如果有就直接赋值，如果还没有找到，就会调用valueForUndefinedKey、setValue：forUndefinedKey方法。
KVO的底层实现：
Kvo基于runtime机制实现。当一个对象的属性值发生改变时，会调用系统的willChangeValueForKey：跟didChangeValueForKey：方法。而这两个方法内部会主动调用监听者内部的observeValueForKeyPath方法。
注意点：当释放观察者时，需要移除观察者。
#Runloop和线程的关系？
&Runloop的作用就是管理线程的，当线程的runloop开启后，线程就会在执行完任务后，处于休眠状态，随时等待接受新的任务，而不是退出。
只有主线程的runloop是默认开启的，所以程序在开启后，会一直运行，不会退出。其他线程的runloop如果需要开启，就手动开启。
# class与结构体的区别？
&1、 class是引用类型，struct是值类型。
2、 class可以继承类、接口和被继承，struct只能继承接口，不能被继承。
3、 class有默认的无参构造函数、析构函数，struct没有默认的无参构造函数，且只能声明有参构造函数。
4、 class必须使用new初始化，结构体可以不用new初始化。
5、 作为参数传递时，class变量以按地址方式传递，而struct变量是以按值方式传递
#逃逸闭包跟非逃逸闭包的区别？
&一个接受闭包作为参数的函数，该闭包可能在函数返回后才被调用，也就是说这个闭包逃离了函数的作用域，这种闭包称为逃逸闭包。当你声明一个接受闭包作为形式参数的函数时，你可以在形式参数前写@escaping来明确闭包是可以允许逃逸。
#如何理解多线程Operation的生命周期？
&NSOperation和GCD一样，不用我们管理线程的生命周期，加锁等问题，只要把操作封装进NSOperation中，系统会自动帮我们创建线程，执行操作，而且它是面向对象的，我们使用起来也更加容易和灵活。有一点要记住，不能直接使用NSOperation，要使用它的两个子类NSInvocationOperation和NSBlockOperation。
#GCD，NSOperation，GCD线程依赖如何处理？
&NSOperation：addDependency ，先执行后者线程。
GCD使用Group，group.enter,group.leave,group.notify
栅栏dispatch_semaphore_wait()，注意这个方法必须在另一个线程调用，不能再主线程调用，因为会阻塞当前线程，造成主线程卡死。
#AOP
&面向切面编程，典型的例子就是runtime中的方法交换，method Swizzling，出名的SDK是Aspects，实战中运用如：统计用户的行为、时间统计等。
#泛型相关问题，什么场景使用泛型，怎么写泛型？
&1）在集合（数组NSArray、字典NSDictionary、集合NSSet）中使用泛型比较常见。
2）在声明一个类，但是类里面的某些属性的类型不确定的时候，我们才使用泛型。
好处：
1）使用泛型后对象或集合内只能放入指定的数据类型，避免出现对象或者集合内的对象在多态使用的时候出现类型转换异常，可以保证数据的安全性。
2）指定了类型后，对象、集合或方法内只能使用对应的数据类型，减少类型的转换操作，方便程序员。
#Block避免循环引用？
&只要避免相互强引用就不会造成循环引用，打破引用环的办法为使用__weak来声明block捕获的变量。
#
